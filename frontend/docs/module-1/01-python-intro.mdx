---
id: chapter-1-python-intro
title: "Chapter 1: Python Fundamentals for Robotics"
description: "Learn Python basics essential for robotics development, including data structures, control flow, and object-oriented programming concepts."
sidebar_position: 1
module: 1
part: 1
chapter_index: 1
learning_objectives:
  - Understand Python syntax and basic data types
  - Master control flow (loops, conditionals)
  - Work with functions and modules
  - Apply object-oriented programming principles
prerequisites: []
keywords:
  - Python
  - Programming fundamentals
  - Variables
  - Functions
  - Classes
  - Control flow
---

import {ChapterHeader} from '@site/src/components/ChapterHeader';
import {AIAssistantWidget} from '@site/src/components/AIAssistantWidget';

<ChapterHeader
  chapterNumber={1}
  title="Chapter 1: Python Fundamentals for Robotics"
  description="Learn Python basics essential for robotics development, including data structures, control flow, and object-oriented programming concepts."
  module={1}
  estimatedTime={90}
  objectives={[
    "Understand Python syntax and basic data types",
    "Master control flow (loops, conditionals)",
    "Work with functions and modules",
    "Apply object-oriented programming principles"
  ]}
  prerequisites={[]}
  keywords={[
    "Python",
    "Programming fundamentals",
    "Variables",
    "Functions",
    "Classes",
    "Control flow"
  ]}
/>

## Introduction

Python has become the dominant language in robotics due to its simplicity, readability, and powerful libraries. This chapter covers the foundational Python concepts you'll need to develop robots and robotics simulations.

## Python Basics

### Variables and Data Types

Python uses dynamic typing, meaning variables can hold different types of values:

```python
# Numbers
age = 25
height = 1.75
is_active = True

# Strings
robot_name = "ATLAS-01"
message = "Starting robot initialization"

# Lists (ordered, mutable)
sensors = ["camera", "lidar", "imu"]

# Dictionaries (key-value pairs)
robot_config = {
    "name": "ATLAS-01",
    "weight": 80,
    "height": 1.88,
    "active": True
}

# Tuples (ordered, immutable)
coordinates = (10.5, 20.3, 15.1)
```

### Type Checking

Use `type()` to check variable types:

```python
print(type(age))  # <class 'int'>
print(type(height))  # <class 'float'>
print(type(robot_name))  # <class 'str'>
print(type(sensors))  # <class 'list'>
```

## Control Flow

### Conditionals

Use `if`, `elif`, and `else` for decision making:

```python
battery_level = 45

if battery_level > 80:
    print("Battery full")
elif battery_level > 50:
    print("Battery good")
elif battery_level > 20:
    print("Battery low - return to charging station")
else:
    print("Battery critical - emergency shutdown")
```

### Loops

**For loops** iterate over sequences:

```python
# Iterate over a list
sensors = ["camera", "lidar", "imu", "gyroscope"]
for sensor in sensors:
    print(f"Initializing {sensor}")

# Iterate with range
for i in range(5):  # 0, 1, 2, 3, 4
    print(f"Iteration {i}")

# Enumerate to get index and value
for index, sensor in enumerate(sensors):
    print(f"Sensor {index}: {sensor}")
```

**While loops** repeat while a condition is true:

```python
step_count = 0
max_steps = 100

while step_count < max_steps:
    # Take a step
    step_count += 1
    if step_count % 10 == 0:
        print(f"Completed {step_count} steps")

print(f"Total steps: {step_count}")
```

## Functions

Functions organize code into reusable blocks:

```python
# Simple function
def greet_robot(name):
    print(f"Hello, {name}!")

greet_robot("ATLAS-01")  # Output: Hello, ATLAS-01!

# Function with return value
def calculate_distance(x1, y1, x2, y2):
    """Calculate Euclidean distance between two points."""
    dx = x2 - x1
    dy = y2 - y1
    distance = (dx**2 + dy**2)**0.5
    return distance

dist = calculate_distance(0, 0, 3, 4)
print(f"Distance: {dist}")  # Distance: 5.0

# Function with default parameters
def initialize_robot(name, weight=80, height=1.88):
    print(f"Robot: {name}, Weight: {weight}kg, Height: {height}m")

initialize_robot("ATLAS-01")  # Uses defaults
initialize_robot("SPOT", weight=25, height=1.0)  # Overrides defaults

# Multiple return values
def get_robot_status():
    battery = 85
    temperature = 42
    error_count = 0
    return battery, temperature, error_count

battery, temp, errors = get_robot_status()
print(f"Battery: {battery}%, Temp: {temp}Â°C, Errors: {errors}")
```

## Object-Oriented Programming

### Classes and Objects

Classes define blueprints for objects:

```python
class Robot:
    """Base class for robots."""

    # Class variable (shared by all instances)
    total_robots = 0

    def __init__(self, name, weight, height):
        """Constructor - called when creating a new robot."""
        self.name = name
        self.weight = weight
        self.height = height
        self.battery = 100
        self.is_active = False
        Robot.total_robots += 1

    def __str__(self):
        """String representation of the robot."""
        return f"Robot: {self.name} ({self.weight}kg, {self.height}m)"

    def power_on(self):
        """Turn on the robot."""
        self.is_active = True
        print(f"{self.name} powered on")

    def power_off(self):
        """Turn off the robot."""
        self.is_active = False
        print(f"{self.name} powered off")

    def get_battery(self):
        """Return current battery level."""
        return self.battery

    def charge(self, amount=10):
        """Charge the battery."""
        self.battery = min(100, self.battery + amount)
        print(f"{self.name} charged to {self.battery}%")

# Create robot instances
atlas = Robot("ATLAS-01", 80, 1.88)
spot = Robot("SPOT", 25, 1.0)

print(atlas)  # Robot: ATLAS-01 (80kg, 1.88m)
print(spot)   # Robot: SPOT (25kg, 1.0m)
print(f"Total robots created: {Robot.total_robots}")  # 2

atlas.power_on()
atlas.charge(20)
print(f"Battery: {atlas.get_battery()}%")  # Battery: 100%
```

### Inheritance

Create specialized classes from base classes:

```python
class HumanoidRobot(Robot):
    """Specialized robot with bipedal locomotion."""

    def __init__(self, name, weight, height, num_fingers=5):
        super().__init__(name, weight, height)
        self.num_fingers = num_fingers
        self.legs = 2
        self.arms = 2

    def walk(self, steps):
        """Walk forward by the specified number of steps."""
        if self.is_active:
            print(f"{self.name} walking {steps} steps")
            return steps
        else:
            print(f"{self.name} is not active")
            return 0

    def reach(self, target_position):
        """Reach towards a target position."""
        if self.is_active:
            print(f"{self.name} reaching to {target_position}")
            return True
        return False

class QuadrupedRobot(Robot):
    """Specialized robot with four-legged locomotion."""

    def __init__(self, name, weight, height):
        super().__init__(name, weight, height)
        self.legs = 4

    def trot(self, distance):
        """Trot forward by the specified distance."""
        if self.is_active:
            print(f"{self.name} trotting {distance} meters")
            return distance
        return 0

# Use specialized classes
atlas = HumanoidRobot("ATLAS", 80, 1.88)
atlas.power_on()
atlas.walk(10)
atlas.reach((1.0, 0.5, 0.3))

spot = QuadrupedRobot("SPOT", 25, 1.0)
spot.power_on()
spot.trot(5)
```

## Working with Lists and Dictionaries

### List Operations

```python
movements = ["walk", "run", "jump", "stand"]

# Add elements
movements.append("crawl")
movements.extend(["kick", "punch"])

# Remove elements
movements.remove("stand")  # Remove by value
movements.pop(0)  # Remove by index

# Access elements
first = movements[0]
last = movements[-1]  # Negative indexing

# Slicing
subset = movements[1:3]  # Elements at index 1 and 2

# List comprehension (create lists elegantly)
numbers = [1, 2, 3, 4, 5]
squared = [x**2 for x in numbers]  # [1, 4, 9, 16, 25]
even_squared = [x**2 for x in numbers if x % 2 == 0]  # [4, 16]
```

### Dictionary Operations

```python
# Create and access
sensor_data = {
    "temperature": 42,
    "humidity": 65,
    "pressure": 1013
}

print(sensor_data["temperature"])  # 42
print(sensor_data.get("temperature", 0))  # 42 (safe access)

# Add or update
sensor_data["light_level"] = 800
sensor_data.update({"temperature": 43})

# Check existence
if "temperature" in sensor_data:
    print("Temperature sensor exists")

# Iterate
for key, value in sensor_data.items():
    print(f"{key}: {value}")

# Dictionary comprehension
angles = {f"joint_{i}": 0 for i in range(6)}
# {'joint_0': 0, 'joint_1': 0, ...}
```

## Error Handling

Handle errors gracefully with try-except:

```python
def divide_numbers(a, b):
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        print("Error: Cannot divide by zero")
        return None
    except TypeError:
        print("Error: Invalid data types")
        return None

print(divide_numbers(10, 2))  # 5.0
print(divide_numbers(10, 0))  # Error: Cannot divide by zero
print(divide_numbers("10", 2))  # Error: Invalid data types
```

## Modules and Imports

Python's power comes from its extensive libraries:

```python
# Import entire module
import math
angle_radians = math.pi / 4
angle_degrees = math.degrees(angle_radians)

# Import specific function
from math import sqrt, cos, sin
distance = sqrt(9)  # 3.0

# Import with alias
import numpy as np
array = np.array([1, 2, 3, 4, 5])

# Import everything (less common)
from math import *
result = sin(angle_radians)
```

## Summary

| Concept | Purpose | Example |
|---------|---------|---------|
| Variables | Store data | `robot_name = "ATLAS"` |
| Lists | Ordered collections | `sensors = ["camera", "lidar"]` |
| Dictionaries | Key-value storage | `config = {"name": "ATLAS", "weight": 80}` |
| Functions | Reusable code blocks | `def walk(steps):` |
| Classes | Define object blueprints | `class Robot:` |
| Control flow | Make decisions, loop | `if`, `for`, `while` |
| Error handling | Catch exceptions | `try`, `except` |

## Practice Exercises

1. **Create a Sensor class** with properties like name, type, and sampling_rate. Add methods to read values and log data.

2. **Build a motor controller** using a class that has speeds (0-100), directions, and methods to increase/decrease speed.

3. **Write a list of commands** and use a for loop to execute each one, printing the status.

4. **Create a dictionary** storing different joint angles and use a comprehension to normalize all angles to 0-360 degrees.

## Next Steps

Now that you understand Python fundamentals, you're ready to learn about simulation tools in the next chapter. We'll use these concepts to create simulated robots and control them in a virtual environment.

---

<div style={{marginTop: '40px', padding: '20px', background: 'rgba(37, 99, 235, 0.05)', borderRadius: '8px', border: '1px solid rgba(37, 99, 235, 0.1)'}}>

## Have Questions?

Try highlighting any text on this page and asking the AI Teaching Assistant below, or use the chat widget to ask questions about Python fundamentals for robotics!

<AIAssistantWidget
  chapterTitle="Python Fundamentals for Robotics"
  chapterNumber={1}
/>

</div>
